<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic_tww_ftn_vq">
  <title>Function Enhancements</title>
  <body>
    <draft-comment author="msk">default function - demo'ed from Metro China<p>VARIADIC - variable
        number of parameter arguments <xref
          href="http://www.postgresql.org/docs/8.4/static/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS"
          format="html" scope="external">postgresql 8.4 -VARIADIC</xref></p><p>Default function
        values <xref
          href=" http://www.postgresql.org/docs/8.4/static/xfunc-sql.html#XFUNC-SQL-PARAMETER-DEFAULTS"
          format="html" scope="external">postgresql 8.4 -parameter
      defaults</xref></p></draft-comment>
  </body>
  <topic id="topic_ypj_1tn_vq">
    <title>34.4.4. SQL Functions with Variable Numbers of Arguments</title>
    <body>
      <p>
        <b>
          <ph id="XFUNC-SQL-VARIADIC-FUNCTIONS">34.4.4. SQL Functions with Variable Numbers of
            Arguments</ph>
        </b>
      </p>
      <p>SQL functions can be declared to accept variable numbers of arguments, so long as all the
        "optional" arguments are of the same data type. The optional arguments will be passed to the
        function as an array. The function is declared by marking the last parameter as VARIADIC;
        this parameter must be declared as being of an array type. For example:</p>
      <pre>CREATE FUNCTION mleast(VARIADIC numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast 
--------
     -1
(1 row)</pre>
      <p>Effectively, all the actual arguments at or beyond the VARIADIC position are gathered up
        into a one-dimensional array, as if you had written</p>
      <pre>SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- doesn't work</pre>
      <p>You can't actually write that, though â€” or at least, it will not match this function
        definition. A parameter marked VARIADIC matches one or more occurrences of its element type,
        not of its own type.</p>
      <p>Sometimes it is useful to be able to pass an already-constructed array to a variadic
        function; this is particularly handy when one variadic function wants to pass on its array
        parameter to another one. You can do that by specifying VARIADIC in the call:</p>
      <pre>SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);</pre>
      <p>This prevents expansion of the function's variadic parameter into its element type, thereby
        allowing the array argument value to match normally. VARIADIC can only be attached to the
        last actual argument of a function call.</p>
    </body>
  </topic>
  <topic id="topic_jxb_btn_vq">
    <title>34.4.5. SQL Functions with Default Values for Arguments</title>
    <body>
      <p>
        <b>
          <ph>34.4.5. SQL Functions with Default Values for Arguments</ph>
        </b>
      </p>
      <p>Functions can be declared with default values for some or all input arguments. The default
        values are inserted whenever the function is called with insufficiently many actual
        arguments. Since arguments can only be omitted from the end of the actual argument list, all
        parameters after a parameter with a default value have to have default values as well.</p>
      <p>For example:</p>
      <pre>CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo 
-----
  60
(1 row)

SELECT foo(10, 20);
 foo 
-----
  33
(1 row)

SELECT foo(10);
 foo 
-----
  15
(1 row)

SELECT foo();  -- fails since there is no default for the first argument
ERROR:  function foo() does not exist</pre>
      <p>The = sign can also be used in place of the key word DEFAULT,</p>
    </body>
  </topic>
</topic>
