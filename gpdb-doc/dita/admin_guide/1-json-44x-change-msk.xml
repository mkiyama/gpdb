<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="ih135496">Working with JSON Data</title>
  <body>
    <draft-comment author="msk">DRAFT - json data type support <xref
        href="https://www.pivotaltracker.com/story/show/78313302" format="html" scope="external"
        >https://www.pivotaltracker.com/story/show/78313302</xref><p><b>GIN, jsonb not supported in
          GPDB</b></p><p>Notes for upgrade, or new install?</p><p>Link to postgresql <xref
          href="http://www.postgresql.org/docs/9.4/static/datatype-json.html" format="html"
          scope="external"
        >http://www.postgresql.org/docs/9.4/static/datatype-json.html</xref></p><p>GPDB 5.0.0 is
        using json from postgres 9.3 <xref
          href="https://www.postgresql.org/docs/9.3/static/functions-json.html" format="html"
          scope="external"
      >https://www.postgresql.org/docs/9.3/static/functions-json.html</xref></p></draft-comment>
    <p>Greenplum Database supports the <codeph>json</codeph> data type that stores JSON (JavaScript
      Object Notation) data, as specified in the <xref href="http://rfc7159.net/rfc7159"
        format="html" scope="external">RFC 7159</xref> document and enforces data validity according
      to the JSON rules. There are also JSON-specific functions and operators available for
        <codeph>json</codeph> data. See <xref href="#topic_gn4_x3w_mq" format="dita"/>. </p>
    <p>When Greenplum Database stores data as <codeph>json</codeph> data type, an exact copy of the
      input text is stored and the JSON processing functions reparse the data on each execution.<ul
        id="ul_lzs_c5p_fz">
        <li>Semantically-insignificant white space between tokens is retained, as well as the order
          of keys within JSON objects. </li>
        <li>All key/value pairs are kept even if a JSON object within the value contains the same
          key more than once. The JSON processing functions consider the last value as the operative
          one.</li>
      </ul></p>
    <p>Greenplum Database allows only one character set encoding per database. It is not possible
      for the <codeph>json</codeph> type to conform rigidly to the JSON specification unless the
      database encoding is UTF8. Attempts to include characters that cannot be represented in the
      database encoding will fail. Characters that can be represented in the database encoding but
      not in UTF8 are allowed.</p>
    <p>The RFC 7159 document permits JSON strings to contain Unicode escape sequences denoted by
          <codeph>\u<varname>XXXX</varname></codeph>. For the <codeph>json</codeph> type, the
      Greenplum Database input function allows Unicode escapes regardless of the database encoding
      and checks Unicode escapes only for syntactic correctness (four hex digits following
        <codeph>\u</codeph>). </p>
    <note>Many of the JSON processing functions described in <xref href="#topic_gn4_x3w_mq"
        format="dita">JSON Functions and Operators</xref> convert Unicode escapes to regular
      characters. The functions throw an error for characters that cannot be represented in the
      database encoding. You should avoid mixing Unicode escapes in JSON with a non-UTF8 database
      encoding, if possible.</note>
  </body>
  <topic id="topic_isn_ltw_mq">
    <title>JSON Input and Output Syntax</title>
    <body>
      <p>The input and output syntax for the <codeph>json</codeph> data type is as specified in RFC
        7159.</p>
      <p>The following are all valid <codeph>json</codeph> expressions:</p>
      <pre>-- Simple scalar/primitive value
-- Primitive values can be numbers, quoted strings, true, false, or null
SELECT '5'::json;

-- Array of zero or more elements (elements need not be of same type)
SELECT '[1, 2, "foo", null]'::json;

-- Object containing pairs of keys and values
-- Note that object keys must always be quoted strings
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-- Arrays and objects can be nested arbitrarily
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;</pre>
    </body>
  </topic>
  <topic id="topic_eyt_3tw_mq">
    <title>Designing JSON documents effectively</title>
    <body>
      <p>Representing data as JSON can be considerably more flexible than the traditional relational
        data model, which is compelling in environments where requirements are fluid. It is quite
        possible for both approaches to co-exist and complement each other within the same
        application. However, even for applications where maximal flexibility is desired, it is
        still recommended that JSON documents have a somewhat fixed structure. The structure is
        typically unenforced (though enforcing some business rules declaratively is possible), but
        having a predictable structure makes it easier to write queries that usefully summarize a
        set of "documents" (datums) in a table.</p>
      <p>JSON data is subject to the same concurrency-control considerations as any other data type
        when stored in a table. Although storing large documents is practicable, keep in mind that
        any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a
        manageable size in order to decrease lock contention among updating transactions. Ideally,
        JSON documents should each represent an atomic datum that business rules dictate cannot
        reasonably be further subdivided into smaller datums that could be modified
        independently.</p>
    </body>
  </topic>
  <topic id="topic_gn4_x3w_mq">
    <title>JSON Functions and Operators</title>
    <body>
      <p>Functions and operators to work with JSON data.<ul id="ul_ypx_f4w_2z">
          <li><xref href="#topic_o5y_14w_2z" format="dita"/></li>
          <li><xref href="#topic_u4s_wnw_2z" format="dita"/></li>
          <li><xref href="#topic_z5d_snw_2z" format="dita"/></li>
        </ul></p>
      <note>For <codeph>json</codeph> values, all key/value pairs are kept even if a JSON object
        contains duplicate key/value pairs. The processing functions consider the last value as the
        operative one.</note>
    </body>
  </topic>
  <topic id="topic_o5y_14w_2z">
    <title>JSON Operators</title>
    <body>
      <p>The following table shows the operators that are available for use with the
          <codeph>json</codeph> data type.</p>
      <table id="table_e41_y3w_mq">
        <title><varname>json</varname> Operators</title>
        <tgroup cols="5">
          <colspec colnum="1" colname="col1" colwidth="1*"/>
          <colspec colnum="2" colname="col2" colwidth="1.17*"/>
          <colspec colnum="3" colname="col3" colwidth="2.79*"/>
          <colspec colnum="4" colname="col4" colwidth="2.78*"/>
          <colspec colnum="5" colname="col5" colwidth="1.92*"/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Right Operand Type</entry>
              <entry>Description</entry>
              <entry>Example</entry>
              <entry>Example Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <codeph>-></codeph>
              </entry>
              <entry>
                <codeph>int</codeph>
              </entry>
              <entry>Get JSON array element (indexed from zero).</entry>
              <entry>
                <codeph>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2</codeph>
              </entry>
              <entry>
                <codeph>{"c":"baz"}</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>-></codeph>
              </entry>
              <entry>
                <codeph>text</codeph>
              </entry>
              <entry>Get JSON object field by key.</entry>
              <entry>
                <codeph>'{"a": {"b":"foo"}}'::json->'a'</codeph>
              </entry>
              <entry>
                <codeph>{"b":"foo"}</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>->></codeph>
              </entry>
              <entry>
                <codeph>int</codeph>
              </entry>
              <entry>Get JSON array element as text.</entry>
              <entry>
                <codeph>'[1,2,3]'::json->>2</codeph>
              </entry>
              <entry>
                <codeph>3</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>->></codeph>
              </entry>
              <entry>
                <codeph>text</codeph>
              </entry>
              <entry>Get JSON object field as text.</entry>
              <entry>
                <codeph>'{"a":1,"b":2}'::json->>'b'</codeph>
              </entry>
              <entry>
                <codeph>2</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>#></codeph>
              </entry>
              <entry>
                <codeph>text[]</codeph>
              </entry>
              <entry>Get JSON object at specified path.</entry>
              <entry><codeph>'{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}</codeph>'</entry>
              <entry>
                <codeph>{"c": "foo"}</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>#>></codeph>
              </entry>
              <entry>
                <codeph>text[]</codeph>
              </entry>
              <entry>Get JSON object at specified path as text.</entry>
              <entry>
                <codeph>'{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'</codeph>
              </entry>
              <entry>
                <codeph>3</codeph>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </body>
  </topic>
  <topic id="topic_u4s_wnw_2z">
    <title>JSON Creation Functions</title>
    <body>
      <p>The <xref href="#topic_gn4_x3w_mq/table_sqb_y3w_mq" format="dita">JSON Creation
          Functions</xref> table shows the functions that are available for creating
          <codeph>json</codeph> values.</p>
      <table id="table_sqb_y3w_mq">
        <title>JSON Creation Functions</title>
        <tgroup cols="4">
          <colspec colnum="1" colname="col1"/>
          <colspec colnum="2" colname="col2"/>
          <colspec colnum="3" colname="col3"/>
          <colspec colnum="4" colname="col4"/>
          <thead>
            <row>
              <entry>Function</entry>
              <entry>Description</entry>
              <entry>Example</entry>
              <entry>Example Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <codeph>to_json(anyelement)</codeph>
              </entry>
              <entry>Returns the value as a JSON object. Arrays and composites are processed
                recursively and are converted to arrays and objects. If the input contains a cast
                from the type to <cmdname>json</cmdname>, the cast function is used to perform the
                conversion; otherwise, a JSON scalar value is produced. For any scalar type other
                than a number, a Boolean, or a null value, the text representation will be used,
                properly quoted and escaped so that it is a valid JSON string.</entry>
              <entry>
                <codeph>to_json('Fred said "Hi."'::text)</codeph>
              </entry>
              <entry>
                <codeph>"Fred said \"Hi.\""</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>array_to_json(anyarray [, pretty_bool])</codeph>
              </entry>
              <entry>Returns the array as a JSON array. A PostgreSQL multidimensional array becomes
                a JSON array of arrays. <p>Line feeds will be added between dimension-1 elements if
                    <cmdname>pretty_bool</cmdname> is true.</p></entry>
              <entry>
                <codeph>array_to_json('{{1,5},{99,100}}'::int[])</codeph>
              </entry>
              <entry>
                <codeph>[[1,5],[99,100]]</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>row_to_json(record [, pretty_bool])</codeph>
              </entry>
              <entry>Returns the row as a JSON object. <p>Line feeds will be added between level-1
                  elements if <cmdname>pretty_bool</cmdname> is true.</p></entry>
              <entry>
                <codeph>row_to_json(row(1,'foo'))</codeph>
              </entry>
              <entry>
                <codeph>{"f1":1,"f2":"foo"}</codeph>
              </entry>
            </row>
            <row>
              <entry><codeph>json_build_array(VARIADIC "any"</codeph>)</entry>
              <entry>Builds a possibly-heterogeneously-typed JSON array out of a
                  <cmdname>VARIADIC</cmdname> argument list.</entry>
              <entry>
                <codeph>json_build_array(1,2,'3',4,5)</codeph>
              </entry>
              <entry>
                <codeph>[1, 2, "3", 4, 5]</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>json_build_object(VARIADIC "any")</codeph>
              </entry>
              <entry>Builds a JSON object out of a <cmdname>VARIADIC</cmdname> argument list. The
                argument list is taken in order and converted to a set of key/value pairs.</entry>
              <entry>
                <codeph>json_build_object('foo',1,'bar',2)</codeph>
              </entry>
              <entry>
                <codeph>{"foo": 1, "bar": 2}</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>json_object(text[])</codeph>
              </entry>
              <entry>Builds a JSON object out of a text array. The array must be either a one or a
                two dimensional array.<p>The one dimensional array must have an even number of
                  elements. The elements are taken as key/value pairs. </p><p>For a two dimensional
                  array, each inner array must have exactly two elements, which are taken as a
                  key/value pair.</p></entry>
              <entry>
                <p>
                  <codeph>json_object('{a, 1, b, "def", c, 3.5}')</codeph>
                </p>
                <p>
                  <codeph>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</codeph>
                </p>
              </entry>
              <entry>
                <codeph>{"a": "1", "b": "def", "c": "3.5"}</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>json_object(keys text[], values text[])</codeph>
              </entry>
              <entry>Builds a JSON object out of a text array. This form of
                  <codeph>json_object</codeph> takes keys and values pairwise from two separate
                arrays. In all other respects it is identical to the one-argument form.</entry>
              <entry>
                <codeph>json_object('{a, b}', '{1,2}')</codeph>
              </entry>
              <entry>
                <codeph>{"a": "1", "b": "2"}</codeph>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note><codeph>array_to_json</codeph> and <codeph>row_to_json</codeph> have the same behavior
        as <codeph>to_json</codeph> except for offering a pretty-printing option. The behavior
        described for <codeph>to_json</codeph> also applies to individual values converted by the
        other JSON creation functions.</note>
    </body>
    <topic id="topic_nds_bnw_2z">
      <title>JSON Aggregate Functions</title>
      <body>
        <p>The <xref href="#topic_nds_bnw_2z/table_rbb_rnw_2z" format="dita">JSON Aggregate
            Functions</xref> table shows the functions that combine data into <codeph>json</codeph>
          values. </p>
        <table id="table_rbb_rnw_2z">
          <title>JSON Aggregate Functions</title>
          <tgroup cols="4">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <colspec colnum="3" colname="col3"/>
            <colspec colnum="4" colname="col4"/>
            <thead>
              <row>
                <entry>Function</entry>
                <entry>Agument Types</entry>
                <entry>Return Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>json_agg(record)</codeph>
                </entry>
                <entry>
                  <codeph>record</codeph>
                </entry>
                <entry>
                  <codeph>json</codeph>
                </entry>
                <entry>Aggregates records as a JSON array of objects.</entry>
              </row>
              <row>
                <entry>
                  <codeph>json_object_agg(name, value)</codeph>
                </entry>
                <entry>
                  <codeph>("any", "any")</codeph>
                </entry>
                <entry>
                  <codeph>json</codeph>
                </entry>
                <entry>Aggregates name/value pairs as a JSON object.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </body>
    </topic>
  </topic>
  <topic id="topic_z5d_snw_2z">
    <title>JSON Processing Functions</title>
    <body>
      <p><xref href="#topic_z5d_snw_2z/table_wfc_y3w_mq" format="dita"/> shows the functions that
        are available for processing <codeph>json</codeph> values.</p>
      <table id="table_wfc_y3w_mq">
        <title>JSON Processing Functions</title>
        <tgroup cols="5">
          <colspec colnum="1" colname="col1" colwidth="1.08*"/>
          <colspec colnum="2" colname="col2" colwidth="1*"/>
          <colspec colnum="3" colname="col3" colwidth="1.01*"/>
          <colspec colnum="4" colname="col4" colwidth="1.24*"/>
          <colspec colnum="5" colname="col5" colwidth="1.01*"/>
          <thead>
            <row>
              <entry>Function</entry>
              <entry>Return Type</entry>
              <entry>Description</entry>
              <entry>Example</entry>
              <entry>Example Result</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <p>
                  <codeph>json_array_length(json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>int</codeph>
              </entry>
              <entry>Returns the number of elements in the outermost JSON array.</entry>
              <entry>
                <codeph>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</codeph>
              </entry>
              <entry>
                <codeph>5</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_each(json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>setof key text, value json</codeph>
                <p>
                  <codeph>setof key text, value jsonb</codeph>
                </p>
              </entry>
              <entry>Expands the outermost JSON object into a set of key/value pairs.</entry>
              <entry>
                <codeph>select * from json_each('{"a":"foo", "b":"bar"}')</codeph>
              </entry>
              <entry>
                <pre> key | value
-----+-------
 a   | "foo"
 b   | "bar"
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>json_each_text(json)</codeph>
              </entry>
              <entry>
                <codeph>setof key text, value text</codeph>
              </entry>
              <entry>Expands the outermost JSON object into a set of key/value pairs. The returned
                values will be of type text.</entry>
              <entry>
                <codeph>select * from json_each_text('{"a":"foo", "b":"bar"}')</codeph>
              </entry>
              <entry>
                <pre> key | value
-----+-------
 a   | foo
 b   | bar
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_extract_path(from_json json, VARIADIC path_elems text[])</codeph>
                </p>
              </entry>
              <entry>
                <p>
                  <codeph>json</codeph>
                </p>
                <p>
                  <codeph>jsonb</codeph>
                </p>
              </entry>
              <entry>Returns JSON value pointed to by <codeph>path_elems</codeph> (equivalent to
                  <codeph>#></codeph> operator).</entry>
              <entry>
                <codeph>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</codeph>
              </entry>
              <entry>
                <codeph>{"f5":99,"f6":"foo"}</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_extract_path_text(from_json json, VARIADIC path_elems
                    text[])</codeph>
                </p>
              </entry>
              <entry>
                <codeph>text</codeph>
              </entry>
              <entry>Returns JSON value pointed to by <codeph>path_elems</codeph> as text
                (equivalent to <codeph>#>></codeph> operator).</entry>
              <entry>
                <codeph>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4',
                  'f6')</codeph>
              </entry>
              <entry>
                <codeph>foo</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_object_keys(json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>setof text</codeph>
              </entry>
              <entry>Returns set of keys in the outermost JSON object.</entry>
              <entry>
                <codeph>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</codeph>
              </entry>
              <entry>
                <pre> json_object_keys
------------------
 f1
 f2
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_populate_record(base anyelement, from_json json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>anyelement</codeph>
              </entry>
              <entry>Expands the object in <codeph>from_json</codeph> to a row whose columns match
                the record type defined by base. See <xref href="#topic_gn4_x3w_mq/json-note"
                  format="dita">Note</xref>.</entry>
              <entry>
                <codeph>select * from json_populate_record(null::myrowtype,
                  '{"a":1,"b":2}')</codeph>
              </entry>
              <entry>
                <pre> a | b
---+---
 1 | 2
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_populate_recordset(base anyelement, from_json json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>setof anyelement</codeph>
              </entry>
              <entry>Expands the outermost array of objects in <codeph>from_json</codeph> to a set
                of rows whose columns match the record type defined by base. See <xref
                  href="#topic_gn4_x3w_mq/json-note" format="dita">Note</xref>.</entry>
              <entry>
                <codeph>select * from json_populate_recordset(null::myrowtype,
                  '[{"a":1,"b":2},{"a":3,"b":4}]')</codeph>
              </entry>
              <entry>
                <pre> a | b
---+---
 1 | 2
 3 | 4
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_array_elements(json)</codeph>
                </p>
              </entry>
              <entry>
                <p>
                  <codeph>setof json</codeph>
                </p>
              </entry>
              <entry>Expands a JSON array to a set of JSON values.</entry>
              <entry>
                <codeph>select * from json_array_elements('[1,true, [2,false]]')</codeph>
              </entry>
              <entry>
                <pre>   value
-----------
 1
 true
 [2,false]
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_array_elements_text(json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>setof text</codeph>
              </entry>
              <entry>Expands a JSON array to a set of <codeph>text</codeph> values.</entry>
              <entry>
                <codeph>select * from json_array_elements_text('["foo", "bar"]')</codeph>
              </entry>
              <entry>
                <pre>   value
-----------
 foo
 bar
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_typeof(json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>text</codeph>
              </entry>
              <entry>Returns the type of the outermost JSON value as a text string. Possible types
                are <codeph>object</codeph>, <codeph>array</codeph>, <codeph>string</codeph>,
                  <codeph>number</codeph>, <codeph>boolean</codeph>, and
                <codeph>null</codeph>.</entry>
              <entry>
                <codeph>json_typeof('-123.4')</codeph>
              </entry>
              <entry>
                <codeph>number</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_to_record(json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>record</codeph>
              </entry>
              <entry>Builds an arbitrary record from a JSON object (see note below). As with all
                functions returning record, the caller must explicitly define the structure of the
                record with an <cmdname>AS</cmdname> clause.</entry>
              <entry>
                <codeph>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b
                  text, d text)</codeph>
              </entry>
              <entry>
                <pre> a |    b    | d
---+---------+---
 1 | [1,2,3] |
</pre>
              </entry>
            </row>
            <row>
              <entry>
                <p>
                  <codeph>json_to_recordset(json)</codeph>
                </p>
              </entry>
              <entry>
                <codeph>setof record</codeph>
              </entry>
              <entry>Builds an arbitrary set of records from a JSON array of objects (see note
                below). As with all functions returning record, the caller must explicitly define
                the structure of the record with an <cmdname>AS</cmdname> clause.</entry>
              <entry>
                <codeph>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]')
                  as x(a int, b text);</codeph>
              </entry>
              <entry>
                <pre> a |  b
---+-----
 1 | foo
 2 |
</pre>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note id="json-note">Many of these functions and operators convert Unicode escapes in JSON
        strings to regular characters. The functions throw an error for characters that cannot be
        represented in the database encoding.<p>In <codeph>json_populate_record</codeph>,
            <codeph>json_populate_recordset</codeph>, <codeph>json_to_record</codeph> and
            <codeph>json_to_recordset</codeph>, type coercion from the JSON is best effort and might
          not result in desired values for some types. JSON keys are matched to identical column
          names in the target row type. JSON fields that do not appear in the target row type will
          be omitted from the output, and target columns that do not match any JSON field will
          simply be <codeph>NULL</codeph>.</p><p>The <codeph>json_typeof</codeph> function null
          return value of <codeph>null</codeph> should not be confused with a SQL
            <codeph>NULL</codeph>. While calling <codeph>json_typeof('null'::json)</codeph> will
          return <codeph>null</codeph>, calling <codeph>json_typeof(NULL::json)</codeph> will return
          a SQL <codeph>NULL</codeph>.</p></note>
    </body>
  </topic>
</topic>
