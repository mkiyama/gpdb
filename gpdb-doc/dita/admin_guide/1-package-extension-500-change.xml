<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1">
  <title id="cw20941">Packaging Related Objects into an Extension</title>
  <body>
    <draft-comment author="msk">5000 DRAFT - packaging an extension.<p>PORT postgres 9.6 <xref
          href="https://www.postgresql.org/docs/9.6/static/extend-extensions.html" format="html"
          scope="external">Section 36.15</xref></p><p>TODO -- edit, formatting, and postgres ->
        GPDB</p></draft-comment>
    <p>A useful extension to Greenplum Database typically includes multiple SQL objects; for
      example, a new data type will require new functions, new operators, and probably new index
      operator classes. It is helpful to collect all these objects into a single package to simplify
      database management. Greenplum Database calls such a package an <i>extension</i>. To define an
      extension, you need at least a <i>script file</i> that contains the SQL commands to create the
      extension objects, and a <i>control file</i> that specifies a few basic properties of the
      extension itself. If the extension includes C code, the extension typically includes a shared
      library file into which the C code has been built. Once you have these files, a <codeph>CREATE
        EXTENSION</codeph> command loads the objects into your database.</p>
    <draft-comment author="msk">Updates to gpcrondump and gpdbrestore?</draft-comment>
    <p>The main advantage of using an extension, rather than just running the SQL script to load a
      bunch of "loose" objects into your database, is that Greenplum Database will then understand
      that the objects of the extension go together. You can drop all the objects with a single
        <xref href="https://www.postgresql.org/docs/9.6/static/sql-dropextension.html" format="html"
        scope="external">DROP EXTENSION</xref> command (no need to maintain a separate "uninstall"
      script). Even more useful, pg_dump knows that it should not dump the individual member objects
      of the extension â€” it will just include a CREATE EXTENSION command in dumps, instead. This
      vastly simplifies migration to a new version of the extension that might contain more or
      different objects than the old version. Note however that you must have the extension's
      control, script, and other files available when loading such a dump into a new database.</p>
    <p>Greenplum Database will not let you drop an individual object contained in an extension,
      except by dropping the whole extension. Also, while you can change the definition of an
      extension member object (for example, via CREATE OR REPLACE FUNCTION for a function), bear in
      mind that the modified definition will not be dumped by pg_dump. Such a change is usually only
      sensible if you concurrently make the same change in the extension's script file. (But there
      are special provisions for tables containing configuration data; see <xref
        href="https://www.postgresql.org/docs/9.6/static/extend-extensions.html#EXTEND-EXTENSIONS-CONFIG-TABLES"
        format="html" scope="external">Section 36.15.3</xref>.) In production situations, it's
      generally better to create an extension update script to perform changes to extension member
      objects.</p>
    <p>The extension script may set privileges on objects that are part of the extension via GRANT
      and REVOKE statements. The final set of privileges for each object (if any are set) will be
      stored in the <xref
        href="https://www.postgresql.org/docs/9.6/static/catalog-pg-init-privs.html" format="html"
        scope="external">pg_init_privs</xref> system catalog. When pg_dump is used, the CREATE
      EXTENSION command will be included in the dump, followed by the set of GRANT and REVOKE
      statements necessary to set the privileges on the objects to what they were at the time the
      dump was taken.</p>
    <p>Greenplum Database does not currently support extension scripts issuing CREATE POLICY or
      SECURITY LABEL statements. These are expected to be set after the extension has been created.
      All RLS policies and security labels on extension objects will be included in dumps created by
      pg_dump.</p>
    <p>The extension mechanism also has provisions for packaging modification scripts that adjust
      the definitions of the SQL objects contained in an extension. For example, if version 1.1 of
      an extension adds one function and changes the body of another function compared to 1.0, the
      extension author can provide an <i>update script</i> that makes just those two changes. The
      ALTER EXTENSION UPDATE command can then be used to apply these changes and track which version
      of the extension is actually installed in a given database.</p>
    <p>The kinds of SQL objects that can be members of an extension are shown in the description of
        <xref href="https://www.postgresql.org/docs/9.6/static/sql-alterextension.html"
        format="html" scope="external">ALTER EXTENSION</xref>. Notably, objects that are
      database-cluster-wide, such as databases, roles, and tablespaces, cannot be extension members
      since an extension is only known within one database. (Although an extension script is not
      prohibited from creating such objects, if it does so they will not be tracked as part of the
      extension.) Also notice that while a table can be a member of an extension, its subsidiary
      objects such as indexes are not directly considered members of the extension. Another
      important point is that schemas can belong to extensions, but not vice versa: an extension as
      such has an unqualified name and does not exist "within" any schema. The extension's member
      objects, however, will belong to schemas whenever appropriate for their object types. It may
      or may not be appropriate for an extension to own the schema(s) its member objects are
      within.</p>
    <p><b><ph>36.15.1. Extension Files</ph></b></p>
    <draft-comment author="msk">SHAREDIR/extension in GPDB?</draft-comment>
    <p>The <xref href="https://www.postgresql.org/docs/9.6/static/sql-createextension.html"
        format="html" scope="external">CREATE EXTENSION</xref> command relies on a control file for
      each extension, which must be named the same as the extension with a suffix of .control, and
      must be placed in the installation's SHAREDIR/extension directory. There must also be at least
      one SQL script file, which follows the naming pattern extension--version.sql (for example,
      foo--1.0.sql for version 1.0 of extension foo). By default, the script file(s) are also placed
      in the SHAREDIR/extension directory; but the control file can specify a different directory
      for the script file(s).</p>
    <p>The file format for an extension control file is the same as for the postgresql.conf file,
      namely a list of <codeph><varname>parameter_name</varname>=<varname>value</varname></codeph>
      assignments, one per line. Blank lines and comments introduced by # are allowed. Be sure to
      quote any value that is not a single word or number.</p>
    <p>A control file can set the following parameters:</p>
    <parml>
      <plentry>
        <pt>directory (string)</pt>
        <pd>
          <p>The directory containing the extension's SQL script file(s). Unless an absolute path is
            given, the name is relative to the installation's SHAREDIR directory. The default
            behavior is equivalent to specifying directory = 'extension'.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>default_version (string)</pt>
        <pd>
          <p>The default version of the extension (the one that will be installed if no version is
            specified in CREATE EXTENSION). Although this can be omitted, that will result in CREATE
            EXTENSION failing if no VERSION option appears, so you generally don't want to do
            that.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>comment (string)</pt>
        <pd>
          <p>A comment (any string) about the extension. The comment is applied when initially
            creating an extension, but not during extension updates (since that might override
            user-added comments). Alternatively, the extension's comment can be set by writing a
              <xref href="https://www.postgresql.org/docs/9.6/static/sql-comment.html" format="html"
              scope="external">COMMENT</xref> command in the script file.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>encoding (string)</pt>
        <pd>
          <p>The character set encoding used by the script file(s). This should be specified if the
            script files contain any non-ASCII characters. Otherwise the files will be assumed to be
            in the database encoding.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>module_pathname (string)</pt>
        <pd>
          <p>The value of this parameter will be substituted for each occurrence of MODULE_PATHNAME
            in the script file(s). If it is not set, no substitution is made. Typically, this is set
            to $libdir/shared_library_name and then MODULE_PATHNAME is used in CREATE FUNCTION
            commands for C-language functions, so that the script files do not need to hard-wire the
            name of the shared library.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>requires (string)</pt>
        <pd>
          <p>A list of names of extensions that this extension depends on, for example requires =
            'foo, bar'. Those extensions must be installed before this one can be installed.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>superuser (boolean)</pt>
        <pd>
          <p>If this parameter is true (which is the default), only superusers can create the
            extension or update it to a new version. If it is set to false, just the privileges
            required to execute the commands in the installation or update script are required.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>relocatable (boolean)</pt>
        <pd>
          <p>An extension is <i>relocatable</i> if it is possible to move its contained objects into
            a different schema after initial creation of the extension. The default is false, i.e.
            the extension is not relocatable. See <xref
              href="https://www.postgresql.org/docs/9.6/static/extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION"
              format="html" scope="external">Section 36.15.2</xref> for more information.</p>
        </pd>
      </plentry>
      <plentry>
        <pt>schema (string)</pt>
        <pd>
          <p>This parameter can only be set for non-relocatable extensions. It forces the extension
            to be loaded into exactly the named schema and not any other. The schema parameter is
            consulted only when initially creating an extension, not during extension updates. See
              <xref
              href="https://www.postgresql.org/docs/9.6/static/extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION"
              format="html" scope="external">Section 36.15.2 - Extension Relocatability</xref> for
            more information.</p>
        </pd>
      </plentry>
    </parml>
    <p>In addition to the primary control file <codeph>extension.control</codeph>, an extension can
      have secondary control files named in the style
        <codeph>extension--<varname>version</varname>.control</codeph>. If supplied, these must be
      located in the script file directory. Secondary control files follow the same format as the
      primary control file. Any parameters set in a secondary control file override the primary
      control file when installing or updating to that version of the extension. However, the
      parameters directory and <codeph>default_version</codeph> cannot be set in a secondary control
      file.</p>
    <p>An extension SQL script files can contain any SQL commands, except for transaction control
      commands such as <codeph>BEGIN</codeph>, <codeph>END</codeph>, and <codeph>COMMIT</codeph>,
      and SQ: commands that cannot be executed inside a transaction block such as
        <codeph>VACUUM</codeph>. This is because the script files are implicitly executed within a
      transaction block.</p>
    <p>An extension SQL script files can also contain lines beginning with <codeph>\echo</codeph>,
      which will be ignored (treated as comments) by the extension mechanism. This provision is
      commonly used to throw an error if the script file is fed to <codeph>psql</codeph> rather than
      being loaded with the <codeph>CREATE EXTENSION</codeph> command. See the example script in
        <xref
        href="https://www.postgresql.org/docs/9.6/static/extend-extensions.html#EXTEND-EXTENSIONS-EXAMPLE"
        format="html" scope="external">Section 36.15.5 - Extension Example</xref>). Without that,
      users might accidentally load the extension's contents as "loose" objects rather than as an
      extension, a state of affairs that's a bit tedious to recover from.</p>
    <p>While the script files can contain any characters allowed by the specified encoding, control
      files should contain only plain ASCII, because there is no way for Greenplum Database to know
      what encoding a control file is in. In practice this is only an issue if you want to use
      non-ASCII characters in the extension's comment. Recommended practice in that case is to not
      use the control file comment parameter, but instead use COMMENT ON EXTENSION within a script
      file to set the comment.</p>
    <p><b><ph>36.15.2. Extension Relocatability</ph></b></p>
    <p>Users often wish to load the objects contained in an extension into a different schema than
      the extension's author had in mind. There are three supported levels of relocatability:</p>
    <ul id="ul_kks_tkf_sz">
      <li>
        <p>A fully relocatable extension can be moved into another schema at any time, even after it
          has been loaded into a database. This is done with the <codeph>ALTER EXTENSION SET
            SCHEMA</codeph> command, which automatically renames all the member objects into the new
          schema. Normally, this is only possible if the extension contains no internal assumptions
          about what schema any of its objects are in. Also, the extension's objects must all be in
          one schema to begin with (ignoring objects that do not belong to any schema, such as
          procedural languages). Mark a fully relocatable extension by setting relocatable = true in
          its control file.</p>
      </li>
      <li>
        <p>An extension might be relocatable during installation but not afterwards. This is
          typically the case if the extension's script file needs to reference the target schema
          explicitly, for example in setting search_path properties for SQL functions. For such an
          extension, set relocatable = false in its control file, and use
            <codeph>@extschema@</codeph> to refer to the target schema in the script file. All
          occurrences of this string will be replaced by the actual target schema name before the
          script is executed. The user can set the target schema using the <codeph>SCHEMA</codeph>
          option of the <codeph>CREATE EXTENSION</codeph> command.</p>
      </li>
      <li>
        <p>If the extension does not support relocation, set <codeph>relocatable = false</codeph> in
          the extension control file, and set schema to the name of the intended target schema. This
          will prevent use of the <codeph>SCHEMA</codeph> option of the <codeph>CREATE
            EXTENSION</codeph> command, unless the command specifies the same schema named in the
          control file. This choice is typically necessary if the extension contains internal
          assumptions about schema names that cannot be replaced by uses of
            <codeph>@extschema@</codeph>. The <codeph>@extschema@</codeph> substitution mechanism is
          available in this case too, although it is of limited use since the schema name is
          determined by the control file.</p>
      </li>
    </ul>
    <p>In all cases, the script file will be executed with <xref
        href="https://www.postgresql.org/docs/9.6/static/runtime-config-client.html#GUC-SEARCH-PATH"
        format="html" scope="external">search_path</xref> initially set to point to the target
      schema; that is, <codeph>CREATE EXTENSION</codeph> does the equivalent of this:</p>
    <codeblock>SET LOCAL search_path TO @extschema@;</codeblock>
    <p>This allows the objects created by the script file to go into the target schema. The script
      file can change <codeph>search_path</codeph> if it wishes, but that is generally undesirable.
        <codeph>search_path</codeph> is restored to its previous setting upon completion of
        <codeph>CREATE EXTENSION</codeph>.</p>
    <p>The target schema is determined by the <codeph>schema</codeph> parameter in the control file
      if that is given, otherwise by the <codeph>SCHEMA</codeph> option of <codeph>CREATE
        EXTENSION</codeph> if that is given, otherwise the current default object creation schema
      (the first schema in the caller <codeph>search_path</codeph>). When the control file schema
      parameter is used, the target schema will be created if it doesn't already exist, but in the
      other two cases it must already exist.</p>
    <p>If any prerequisite extensions are listed in <codeph>requires</codeph> in the control file,
      their target schemas are appended to the initial setting of <codeph>search_path</codeph>. This
      allows their objects to be visible to the new extension script file.</p>
    <p>Although a non-relocatable extension can contain objects spread across multiple schemas, it
      is usually desirable to place all the objects meant for external use into a single schema,
      which is considered the extension's target schema. Such an arrangement works conveniently with
      the default setting of <codeph>search_path</codeph> during creation of dependent
      extensions.</p>
    <p><b><ph>36.15.3. Extension Configuration Tables</ph></b></p>
    <p>Some extensions include configuration tables, which contain data that might be added or
      changed by the user after installation of the extension. Ordinarily, if a table is part of an
      extension, neither the table's definition nor its content will be dumped by
        <codeph>pg_dump</codeph>. But that behavior is undesirable for a configuration table; any
      data changes made by the user need to be included in dumps, or the extension will behave
      differently after a dump and reload.</p>
    <p>To solve this problem, an extension's script file can mark a table or a sequence it has
      created as a configuration relation, which will cause <codeph>pg_dump</codeph> to include the
      table's or the sequence's contents (not its definition) in dumps. To do that, call the
      function <codeblock>pg_extension_config_dump(regclass, text)</codeblock> after creating the
      table or the sequence, for example</p>
    <codeblock>CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');</codeblock>
    <p>Any number of tables or sequences can be marked this way. Sequences associated with serial or
      bigserial columns can be marked as well.</p>
    <p>When the second argument of <codeph>pg_extension_config_dump</codeph> is an empty string, the
      entire contents of the table are dumped by <codeph>pg_dump</codeph>. This is usually only
      correct if the table is initially empty as created by the extension script. If there is a
      mixture of initial data and user-provided data in the table, the second argument of
        <codeph>pg_extension_config_dump</codeph> provides a <codeph>WHERE</codeph> condition that
      selects the data to be dumped. For example, you might do</p>
    <codeblock>CREATE TABLE my_config (key text, value text, standard_entry boolean);
SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');</codeblock>
    <p>and then make sure that <codeph>standard_entry</codeph> is <codeph>true</codeph> only in the
      rows created by the extension script.</p>
    <p>For sequences, the second argument of <codeph>pg_extension_config_dump</codeph> has no
      effect.</p>
    <p>More complicated situations, such as initially-provided rows that might be modified by users,
      can be handled by creating triggers on the configuration table to ensure that modified rows
      are marked correctly.</p>
    <p>You can alter the filter condition associated with a configuration table by calling
        <codeph>pg_extension_config_dump</codeph> again. (This would typically be useful in an
      extension update script.) The only way to mark a table as no longer a configuration table is
      to dissociate it from the extension with <codeph>ALTER EXTENSION ... DROP TABLE</codeph>.</p>
    <p>Note that foreign key relationships between these tables will dictate the order in which the
      tables are dumped out by pg_dump. Specifically, pg_dump will attempt to dump the referenced-by
      table before the referencing table. As the foreign key relationships are set up at
        <codeph>CREATE EXTENSION</codeph> time (prior to data being loaded into the tables) circular
      dependencies are not supported. When circular dependencies exist, the data will still be
      dumped out but the dump will not be able to be restored directly and user intervention will be
      required.</p>
    <p>Sequences associated with <codeph>serial</codeph> or <codeph>bigserial</codeph> columns need
      to be directly marked to dump their state. Marking their parent relation is not enough for
      this purpose.</p>
    <p><b><ph>36.15.4. Extension Updates</ph></b></p>
    <p>One advantage of the extension mechanism is that it provides convenient ways to manage
      updates to the SQL commands that define an extension objects. This is done by associating a
      version name or number with each released version of the extension's installation script. In
      addition, if you want users to be able to update their databases dynamically from one version
      to the next, you should provide <i>update scripts</i> that make the necessary changes to go
      from one version to the next. Update scripts have names following the pattern
          <codeph><varname>extension</varname>--<varname>oldversion</varname>--<varname>newversion</varname>.sql</codeph>
      (for example, <codeph>foo--1.0--1.1.sql</codeph> contains the commands to modify version 1.0
      of extension foo into version 1.1).</p>
    <p>Given that a suitable update script is available, the command <codeph>ALTER EXTENSION
        UPDATE</codeph> will update an installed extension to the specified new version. The update
      script is run in the same environment that <codeph>CREATE EXTENSION</codeph> provides for
      installation scripts: in particular, <codeph>search_path</codeph> is set up in the same way,
      and any new objects created by the script are automatically added to the extension.</p>
    <p>If an extension has secondary control files, the control parameters that are used for an
      update script are those associated with the script's target (new) version.</p>
    <p>The update mechanism can be used to solve an important special case: converting a "loose"
      collection of objects into an extension. Before the extension mechanism was added to Greenplum
      Database (in 5.0.0), many people wrote extension modules that simply created assorted
      unpackaged objects. Given an existing database containing such objects, how can we convert the
      objects into a properly packaged extension? Dropping them and then doing a plain
        <codeph>CREATE EXTENSION</codeph> is one way, but it's not desirable if the objects have
      dependencies (for example, if there are table columns of a data type created by the
      extension). The way to fix this situation is to create an empty extension, then use the
      command <codeph>ALTER EXTENSION ADD</codeph> to attach each pre-existing object to the
      extension, then finally create any new objects that are in the current extension version but
      were not in the unpackaged release. <codeph>CREATE EXTENSION</codeph> supports this case with
      the <codeph>FROM <varname>old_version</varname></codeph> option, which causes it to not run
      the normal installation script for the target version, but instead the update script named
          <codeph>extension--<codeph>old_version</codeph>--<codeph>target_version</codeph>.sql</codeph>.
      The choice of the dummy version name to use as <codeph>old_version</codeph> is up to the
      extension author, though unpackaged is a common convention. If you have multiple prior
      versions you need to be able to update into extension style, use multiple dummy version names
      to identify them.</p>
    <p><codeph>ALTER EXTENSION</codeph> is able to execute sequences of update script files to
      achieve a requested update. For example, if only <codeph>foo--1.0--1.1.sql</codeph> and
        <codeph>foo--1.1--2.0.sql</codeph> are available, <codeph>ALTER EXTENSION</codeph> will
      apply them in sequence if an update to version 2.0 is requested when 1.0 is currently
      installed.</p>
    <p>Greenplum Database doesn't assume anything about the properties of version names: for
      example, it does not know whether 1.1 follows 1.0. It just matches up the available version
      names and follows the path that requires applying the fewest update scripts. (A version name
      can actually be any string that doesn't contain <codeph>--</codeph> or leading or trailing
        <codeph>-</codeph>.)</p>
    <p>Sometimes it is useful to provide downgrade scripts, for example
        <codeph>foo--1.1--1.0.sql</codeph> to allow reverting the changes associated with version
      1.1. If you do that, be careful of the possibility that a downgrade script might unexpectedly
      get applied because it yields a shorter path. The risky case is where there is a "fast path"
      update script that jumps ahead several versions as well as a downgrade script to the fast
      path's start point. It might take fewer steps to apply the downgrade and then the fast path
      than to move ahead one version at a time. If the downgrade script drops any irreplaceable
      objects, this will yield undesirable results.</p>
    <p>To check for unexpected update paths, use this command:</p>
    <codeblock>SELECT * FROM pg_extension_update_paths('extension_name');</codeblock>
    <p>This shows each pair of distinct known version names for the specified extension, together
      with the update path sequence that would be taken to get from the source version to the target
      version, or NULL if there is no available update path. The path is shown in textual form with
      -- separators. You can use regexp_split_to_array(path,'--') if you prefer an array format.</p>
    <p><b><ph>36.15.5. Extension Example</ph></b></p>
    <draft-comment author="msk">Requires makefile and PGXS. Will this work?</draft-comment>
    <p>Here is a complete example of an SQL-only extension, a two-element composite type that can
      store any type of value in its slots, which are named <codeph>k</codeph> and
        <codeph>v</codeph>. Non-text values are automatically coerced to text for storage.</p>
    <p>The script file <codeph>pair--1.0.sql</codeph> looks like this:</p>
    <codeblock>-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);</codeblock>
    <p>The control file <codeph>pair.control</codeph> looks like this:</p>
    <codeblock># pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = true</codeblock>
    <p>While you hardly need a makefile to install these two files into the correct directory, you
      could use a <codeph>Makefile</codeph> containing this:</p>
    <codeblock>EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</codeblock>
    <p>This makefile relies on PGXS, which is described in <xref
        href="https://www.postgresql.org/docs/9.6/static/extend-pgxs.html" format="html"
        scope="external">Section 36.16</xref>. The command make install will install the control and
      script files into the correct directory as reported by <codeph>pg_config</codeph>.</p>
    <p>Once the files are installed, use the <codeph>CREATE EXTENSION</codeph> command to load the
      objects into any particular database.</p>
  </body>
</topic>
